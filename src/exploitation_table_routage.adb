with Ada.Text_IO.Unbounded_IO;  use Ada.Text_IO.Unbounded_IO;
with Ada.Text_IO;               use Ada.Text_IO;
with Routeur_Exceptions;        use Routeur_Exceptions;
with utilitaire;                use utilitaire;

package body exploitation_table_routage is

-- Cette fonction est conçue pour lire une ligne du fichier de la table de routage.
-- Cette fonction permet d'enlever les points, les espaces et de séparer les 3 données qui sont la destination, le masque et l'interface.
-- Pour cela on parcours la ligne et dès que l'on trouve un point on récupère l'entier entre ce point et le point précédent.
-- De meme, dès qu'un espace est précédé par un caractère qui n'est pas un espace alors on considère cet espace comme un point.
-- Si l'espace est précédé par un espace alors on incrémente et on poursuit le parcours de la ligne.
   
function lire_ligne (ligne : in Unbounded_string) return T_Donnee is
    donnee : T_donnee;                  -- Récupère la destination, le masque et l'interface.
    indice_point : Integer;             -- Indice d'un point ou d'un espace.
    Nb_point_parcourus : Integer;       -- Nombre de points parcourus.
    somme_destination : T_Adresse_IP;   -- La destination selon le shéma de Horner.
    somme_masque : T_Adresse_IP;        -- Le masque selon le schéma de Horner.
    Eth : Unbounded_String;             -- L'interface.
    indice_espace_eth : Integer;        -- Indice de l'espace avant la chaine de caractère Eth dans la ligne.
begin
    indice_point := 0;
    Nb_point_parcourus := 0;
    somme_destination := 0;
    somme_masque := 0;           
    for i in 1..Length(ligne) loop
        if To_String(ligne)(i) = '.' or To_String(ligne)(i) = ' ' then  -- Vérifie si le caractère de ligne est un point ou un espace.
            if To_String(ligne)(i-1) = ' ' and To_String(ligne)(i) = ' ' then  -- Vérifie que le caractère de la ligne et son caractère précédents sont bien des espaces.
                indice_point := i;
            else 
                
                if Nb_point_parcourus<=3 and ( Integer'Value(To_String(ligne)((indice_point + 1)..i-1)) > 255 or Integer'Value(To_String(ligne)((indice_point + 1)..i-1)) < 0) then
                    raise Constraint_Error with "Le" & Integer'Image(Nb_point_parcourus + 1) & " ème octet de l'adresse IP de la destination n'est pas compris entre 0 et 255.";
                elsif Nb_point_parcourus >= 4 and ( Integer'Value(To_String(ligne)((indice_point + 1)..i-1)) > 255 or Integer'Value(To_String(ligne)((indice_point + 1)..i-1)) < 0) then
                    raise Constraint_Error with "Le" & Integer'Image(Nb_point_parcourus - 3) & " ème octet de l'adresse IP du masque n'est pas compris entre 0 et 255.";
                end if;
                    
                -- Si le nombre de point est inferieur ou égal à 3 alors c'est la destination qui est récupérée par le schéma de Horner
                -- Si le nombre de point est supérieur ou égal à 4 inferieur ou égal à 7 alors c'est le masque qui est récupérée par le schéma de Horner
                   case Nb_point_parcourus is 
                        when 0 =>
                           somme_destination := somme_destination + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 1 =>
                           somme_destination := somme_destination * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 2 =>
                           somme_destination := somme_destination * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 3 =>
                           somme_destination := somme_destination * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 4 =>
                            somme_masque := somme_masque + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 5 =>
                           somme_masque := somme_masque * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 6 =>
                           somme_masque := somme_masque * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when 7 =>
                           somme_masque := somme_masque * 256 + T_adresse_IP'Value(To_String(ligne)((indice_point + 1)..i-1));
                        when others =>
                           raise Adresse_IP_Invalide;
                   end case;
                    Nb_point_parcourus := Nb_point_parcourus + 1;
                    indice_point := i;
                end if; 
               
            elsif i = length(ligne) then -- Vérifie si on a parcouru la ligne.
                indice_espace_eth := length(ligne);
                while To_String(ligne)(indice_espace_eth) /= ' ' loop  -- Le while sert ici à ne pas avoir d'erreur si le chiffre de l'interface possède plus de caractères que 1.
                        indice_espace_eth := indice_espace_eth - 1;
                end loop;
                Eth := To_Unbounded_String(To_String(ligne)(indice_espace_eth..Length(ligne)));
            else 
                null;
           end if;
        end loop;
       donnee := (somme_destination, somme_masque, Eth); -- On utilise le type T_donnée pour stocker et renvoyer les 3 valeurs.
       return donnee;
    end lire_ligne;     

-- Cette fonction est conçue pour créer une liste chainée "table_routage" contenant des cellules représantant les lignes du fichier de la table de routage choisie.
-- Les cellules contiennent la destination, le masque et l'interface. 
    procedure Table_routage(table_routage : in out T_LCA; fichier: in Unbounded_String) is
        Entree : File_Type;	        -- Le descripteur du ficher d'entrée.
        ligne : Unbounded_String;   -- Une ligne de la table de routage.
        donnee : T_Donnee;          -- La destination, le masque et l'interface pour une ligne donée de la table de routage.
    begin
            Open (Entree, In_File, To_String (fichier)); -- Ouvre le fichier de la table de routage 
            begin
                while not End_Of_File(Entree) loop -- Parcourt le fichier jusqu'à sa fin.
                    ligne := Get_Line(Entree);
                    donnee := lire_ligne(ligne); -- récupère la destination, le masque et l'interface de la ligne.
                    Enregistrer(table_routage, donnee.Destination, donnee.Masque, donnee.eth); -- Enregistre la destination, le masque et l'interface dans la liste chainée.
                end loop;
            end;
            
            Close (Entree); -- Ferme le fichier de la table de routage.  
    end Table_routage;

-- Cette fonction est conçue pour créer la ligne contenant la destination et l'interface qui sera à placer dans le fichier résultat.
    function creer_ligne(destination : in T_Adresse_IP; eth : in Unbounded_String) return Unbounded_String is
    ligne : Unbounded_String;   -- Ligne à afficher.
    longueur : Integer;         -- Longueur en caractère de la destination ou du masque.
    
    begin
        for i in 1..3 loop -- De 1 à 3 car on ne souhaite pas avoir de points apres le dernier octet.
            longueur := Length(To_Unbounded_String(Integer'Image(Ieme_Octet (destination, i))));
            ligne := ligne & To_Unbounded_String(Integer'Image(Ieme_Octet (destination, i))(2..longueur)) & "."; -- On commence par le deuxième car à cause de "Integer'Image", il y'a la création d'un espace au début de la chaine de caractère
        end loop;
        longueur := Length(To_Unbounded_String(Integer'Image(Ieme_Octet (destination, 4))));
        ligne := ligne & To_Unbounded_String(Integer'Image(Ieme_Octet (destination, 4))(2..longueur)); -- De meme.
        ligne := ligne & " " & eth;
    
        return ligne;
    end creer_ligne;
end exploitation_table_routage;